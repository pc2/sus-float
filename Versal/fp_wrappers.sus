
extern module fp32_acc_ip {
    domain aclk
    input bool aresetn'0

    domain data
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_a_tlast'0
    output bool m_axis_result_tvalid'2
    output float m_axis_result_tdata'2
    output bool m_axis_result_tlast'2
}

module fp32_acc {
    domain aclk
    input bool aresetn'0

    domain data
    fp32_acc_ip ip
    ip.aresetn = aresetn
    action fp32_acc : float a, bool last -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_a_tlast = last
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
        bool _1 = ip.m_axis_result_tlast // Tie off
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_acc_minus_ip {
    domain aclk
    input bool aresetn'0

    domain data
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_a_tlast'0
    output bool m_axis_result_tvalid'2
    output float m_axis_result_tdata'2
    output bool m_axis_result_tlast'2
}

module fp32_acc_minus {
    domain aclk
    input bool aresetn'0

    domain data
    fp32_acc_minus_ip ip
    ip.aresetn = aresetn
    action fp32_acc_minus : float a, bool last -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_a_tlast = last
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
        bool _1 = ip.m_axis_result_tlast // Tie off
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_add_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output float m_axis_result_tdata'2
}

module fp32_add {
    domain aclk
    
    fp32_add_ip ip
    
    action fp32_add : float a, float b -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_div_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'28
    output float m_axis_result_tdata'28
}

module fp32_div {
    domain aclk
    
    fp32_div_ip ip
    
    action fp32_div : float a, float b -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_eq_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output bool[8] m_axis_result_tdata'2
}

module fp32_eq {
    domain aclk
    
    fp32_eq_ip ip
    
    action fp32_eq : float a, float b -> bool res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata[0]
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_exp_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    output bool m_axis_result_tvalid'20
    output float m_axis_result_tdata'20
}

module fp32_exp {
    domain aclk
    
    fp32_exp_ip ip
    
    action fp32_exp : float a -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_fma_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    input bool s_axis_c_tvalid'0
    input float s_axis_c_tdata'0
    output bool m_axis_result_tvalid'4
    output float m_axis_result_tdata'4
}

module fp32_fma {
    domain aclk
    
    fp32_fma_ip ip
    
    action fp32_fma : float a, float b, float c -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        ip.s_axis_c_tvalid = true
        ip.s_axis_c_tdata = c
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
        ip.s_axis_c_tvalid = false
    }
}

extern module fp32_fms_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    input bool s_axis_c_tvalid'0
    input float s_axis_c_tdata'0
    output bool m_axis_result_tvalid'4
    output float m_axis_result_tdata'4
}

module fp32_fms {
    domain aclk
    
    fp32_fms_ip ip
    
    action fp32_fms : float a, float b, float c -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        ip.s_axis_c_tvalid = true
        ip.s_axis_c_tdata = c
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
        ip.s_axis_c_tvalid = false
    }
}

extern module fp32_ge_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output bool[8] m_axis_result_tdata'2
}

module fp32_ge {
    domain aclk
    
    fp32_ge_ip ip
    
    action fp32_ge : float a, float b -> bool res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata[0]
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_gt_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output bool[8] m_axis_result_tdata'2
}

module fp32_gt {
    domain aclk
    
    fp32_gt_ip ip
    
    action fp32_gt : float a, float b -> bool res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata[0]
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_ln_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    output bool m_axis_result_tvalid'22
    output float m_axis_result_tdata'22
}

module fp32_ln {
    domain aclk
    
    fp32_ln_ip ip
    
    action fp32_ln : float a -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_mac_ip {
    domain aclk
    input bool aresetn'0

    domain data
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_a_tlast'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'4
    output float m_axis_result_tdata'4
    output bool m_axis_result_tlast'4
}

module fp32_mac {
    domain aclk
    input bool aresetn'0

    domain data
    fp32_mac_ip ip
    ip.aresetn = aresetn
    action fp32_mac : float a, float b, bool last -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_a_tlast = last
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
        bool _1 = ip.m_axis_result_tlast // Tie off
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_msc_ip {
    domain aclk
    input bool aresetn'0

    domain data
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_a_tlast'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'4
    output float m_axis_result_tdata'4
    output bool m_axis_result_tlast'4
}

module fp32_msc {
    domain aclk
    input bool aresetn'0

    domain data
    fp32_msc_ip ip
    ip.aresetn = aresetn
    action fp32_msc : float a, float b, bool last -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_a_tlast = last
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
        bool _1 = ip.m_axis_result_tlast // Tie off
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_mul_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'3
    output float m_axis_result_tdata'3
}

module fp32_mul {
    domain aclk
    
    fp32_mul_ip ip
    
    action fp32_mul : float a, float b -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp32_rcp_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    output bool m_axis_result_tvalid'29
    output float m_axis_result_tdata'29
}

module fp32_rcp {
    domain aclk
    
    fp32_rcp_ip ip
    
    action fp32_rcp : float a -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_rsqrt_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    output bool m_axis_result_tvalid'32
    output float m_axis_result_tdata'32
}

module fp32_rsqrt {
    domain aclk
    
    fp32_rsqrt_ip ip
    
    action fp32_rsqrt : float a -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_sqrt_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    output bool m_axis_result_tvalid'28
    output float m_axis_result_tdata'28
}

module fp32_sqrt {
    domain aclk
    
    fp32_sqrt_ip ip
    
    action fp32_sqrt : float a -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp32_sub_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input float s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input float s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output float m_axis_result_tdata'2
}

module fp32_sub {
    domain aclk
    
    fp32_sub_ip ip
    
    action fp32_sub : float a, float b -> float res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_acc_ip {
    domain aclk
    input bool aresetn'0

    domain data
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_a_tlast'0
    output bool m_axis_result_tvalid'22
    output double m_axis_result_tdata'22
    output bool m_axis_result_tlast'22
}

module fp64_acc {
    domain aclk
    input bool aresetn'0

    domain data
    fp64_acc_ip ip
    ip.aresetn = aresetn
    action fp64_acc : double a, bool last -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_a_tlast = last
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
        bool _1 = ip.m_axis_result_tlast // Tie off
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_acc_minus_ip {
    domain aclk
    input bool aresetn'0

    domain data
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_a_tlast'0
    output bool m_axis_result_tvalid'22
    output double m_axis_result_tdata'22
    output bool m_axis_result_tlast'22
}

module fp64_acc_minus {
    domain aclk
    input bool aresetn'0

    domain data
    fp64_acc_minus_ip ip
    ip.aresetn = aresetn
    action fp64_acc_minus : double a, bool last -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_a_tlast = last
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
        bool _1 = ip.m_axis_result_tlast // Tie off
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_add_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'14
    output double m_axis_result_tdata'14
}

module fp64_add {
    domain aclk
    
    fp64_add_ip ip
    
    action fp64_add : double a, double b -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_div_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'57
    output double m_axis_result_tdata'57
}

module fp64_div {
    domain aclk
    
    fp64_div_ip ip
    
    action fp64_div : double a, double b -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_eq_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output bool[8] m_axis_result_tdata'2
}

module fp64_eq {
    domain aclk
    
    fp64_eq_ip ip
    
    action fp64_eq : double a, double b -> bool res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata[0]
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_exp_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    output bool m_axis_result_tvalid'44
    output double m_axis_result_tdata'44
}

module fp64_exp {
    domain aclk
    
    fp64_exp_ip ip
    
    action fp64_exp : double a -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_fma_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    input bool s_axis_c_tvalid'0
    input double s_axis_c_tdata'0
    output bool m_axis_result_tvalid'26
    output double m_axis_result_tdata'26
}

module fp64_fma {
    domain aclk
    
    fp64_fma_ip ip
    
    action fp64_fma : double a, double b, double c -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        ip.s_axis_c_tvalid = true
        ip.s_axis_c_tdata = c
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
        ip.s_axis_c_tvalid = false
    }
}

extern module fp64_fms_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    input bool s_axis_c_tvalid'0
    input double s_axis_c_tdata'0
    output bool m_axis_result_tvalid'26
    output double m_axis_result_tdata'26
}

module fp64_fms {
    domain aclk
    
    fp64_fms_ip ip
    
    action fp64_fms : double a, double b, double c -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        ip.s_axis_c_tvalid = true
        ip.s_axis_c_tdata = c
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
        ip.s_axis_c_tvalid = false
    }
}

extern module fp64_ge_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output bool[8] m_axis_result_tdata'2
}

module fp64_ge {
    domain aclk
    
    fp64_ge_ip ip
    
    action fp64_ge : double a, double b -> bool res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata[0]
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_gt_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'2
    output bool[8] m_axis_result_tdata'2
}

module fp64_gt {
    domain aclk
    
    fp64_gt_ip ip
    
    action fp64_gt : double a, double b -> bool res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata[0]
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_ln_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    output bool m_axis_result_tvalid'48
    output double m_axis_result_tdata'48
}

module fp64_ln {
    domain aclk
    
    fp64_ln_ip ip
    
    action fp64_ln : double a -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_mul_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'12
    output double m_axis_result_tdata'12
}

module fp64_mul {
    domain aclk
    
    fp64_mul_ip ip
    
    action fp64_mul : double a, double b -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}

extern module fp64_rcp_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    output bool m_axis_result_tvalid'35
    output double m_axis_result_tdata'35
}

module fp64_rcp {
    domain aclk
    
    fp64_rcp_ip ip
    
    action fp64_rcp : double a -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_rsqrt_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    output bool m_axis_result_tvalid'110
    output double m_axis_result_tdata'110
}

module fp64_rsqrt {
    domain aclk
    
    fp64_rsqrt_ip ip
    
    action fp64_rsqrt : double a -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_sqrt_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    output bool m_axis_result_tvalid'57
    output double m_axis_result_tdata'57
}

module fp64_sqrt {
    domain aclk
    
    fp64_sqrt_ip ip
    
    action fp64_sqrt : double a -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
    }
}

extern module fp64_sub_ip {
    domain aclk
    
    input bool s_axis_a_tvalid'0
    input double s_axis_a_tdata'0
    input bool s_axis_b_tvalid'0
    input double s_axis_b_tdata'0
    output bool m_axis_result_tvalid'14
    output double m_axis_result_tdata'14
}

module fp64_sub {
    domain aclk
    
    fp64_sub_ip ip
    
    action fp64_sub : double a, double b -> double res {
        ip.s_axis_a_tvalid = true
        ip.s_axis_a_tdata = a
        ip.s_axis_b_tvalid = true
        ip.s_axis_b_tdata = b
        bool _0 = ip.m_axis_result_tvalid // Tie off
        res = ip.m_axis_result_tdata
    } else {
        ip.s_axis_a_tvalid = false
        ip.s_axis_b_tvalid = false
    }
}
