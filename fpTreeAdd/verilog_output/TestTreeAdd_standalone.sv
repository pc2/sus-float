// DO NOT EDIT THIS FILE
// This file was generated with SUS Compiler 0.2.0
// ::TestTreeAdd #()
module TestTreeAdd(
	input clk,
	input wire start,
	input wire[31:0] Array[3:0],
	output /*mux_wire*/ logic[31:0] Result
);

/*latency*/ logic  _start_D1; always_ff @(posedge clk) begin _start_D1 <= start; end
/*latency*/ logic  _start_D2; always_ff @(posedge clk) begin _start_D2 <= _start_D1; end
/*latency*/ logic  _start_D3; always_ff @(posedge clk) begin _start_D3 <= _start_D2; end
/*latency*/ logic  _start_D4; always_ff @(posedge clk) begin _start_D4 <= _start_D3; end
/*latency*/ logic  _start_D5; always_ff @(posedge clk) begin _start_D5 <= _start_D4; end
/*latency*/ logic  _start_D6; always_ff @(posedge clk) begin _start_D6 <= _start_D5; end
/*latency*/ logic  _start_D7; always_ff @(posedge clk) begin _start_D7 <= _start_D6; end
/*latency*/ logic  _start_D8; always_ff @(posedge clk) begin _start_D8 <= _start_D7; end
/*latency*/ logic  _start_D9; always_ff @(posedge clk) begin _start_D9 <= _start_D8; end
/*latency*/ logic  _start_D10; always_ff @(posedge clk) begin _start_D10 <= _start_D9; end
/*latency*/ logic  _start_D11; always_ff @(posedge clk) begin _start_D11 <= _start_D10; end
/*latency*/ logic  _start_D12; always_ff @(posedge clk) begin _start_D12 <= _start_D11; end
/*latency*/ logic  _start_D13; always_ff @(posedge clk) begin _start_D13 <= _start_D12; end
/*latency*/ logic  _start_D14; always_ff @(posedge clk) begin _start_D14 <= _start_D13; end
/*latency*/ logic  _start_D15; always_ff @(posedge clk) begin _start_D15 <= _start_D14; end
/*latency*/ logic  _start_D16; always_ff @(posedge clk) begin _start_D16 <= _start_D15; end
/*latency*/ logic  _start_D17; always_ff @(posedge clk) begin _start_D17 <= _start_D16; end
/*latency*/ logic  _start_D18; always_ff @(posedge clk) begin _start_D18 <= _start_D17; end
/*latency*/ logic  _start_D19; always_ff @(posedge clk) begin _start_D19 <= _start_D18; end
/*latency*/ logic  _start_D20; always_ff @(posedge clk) begin _start_D20 <= _start_D19; end
/*latency*/ logic  _start_D21; always_ff @(posedge clk) begin _start_D21 <= _start_D20; end
/*latency*/ logic  _start_D22; always_ff @(posedge clk) begin _start_D22 <= _start_D21; end
/*latency*/ logic  _start_D23; always_ff @(posedge clk) begin _start_D23 <= _start_D22; end
/*latency*/ logic  _start_D24; always_ff @(posedge clk) begin _start_D24 <= _start_D23; end
genvar _g0;
/*mux_wire*/ logic[31:0] _1_values[3:0];
wire[31:0] _1_total;
fpTreeAdd__WIDTH4 _1(
	.clk(clk),
	.values(_1_values),
	.total(_1_total)
);
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	Result = 'x;
	if(_start_D24) Result = _1_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_1_values[0] = 'x;
	_1_values[1] = 'x;
	_1_values[2] = 'x;
	_1_values[3] = 'x;
	for(int _v0 = 0; _v0 < 4; _v0 = _v0 + 1) if(start) _1_values[_v0] = Array[_v0];
end
endmodule

// ::fpTreeAdd #(
//     WIDTH: 4,
// )
module fpTreeAdd__WIDTH4(
	input clk,
	input wire[31:0] values[3:0],
	output /*mux_wire*/ logic[31:0] total
);

genvar _g0;
/*mux_wire*/ logic[31:0] left_part[1:0];
/*mux_wire*/ logic[31:0] right_part[1:0];
/*mux_wire*/ logic[31:0] split_i[3:0];
wire[31:0] split_left[1:0];
wire[31:0] split_right[1:0];
/*mux_wire*/ logic[31:0] left_total;
/*mux_wire*/ logic[31:0] _1_values[1:0];
wire[31:0] _1_total;
/*mux_wire*/ logic[31:0] right_total;
/*mux_wire*/ logic[31:0] _2_values[1:0];
wire[31:0] _2_total;
/*mux_wire*/ logic[31:0] _3_value1;
/*mux_wire*/ logic[31:0] _3_value2;
wire[31:0] _3_result;
/*latency*/ logic [31:0] __3_result_D24; always_ff @(posedge clk) begin __3_result_D24 <= _3_result; end
fpSplitAt__Ttypefloat_SIZE4_SPLIT_POINT2 split(
	.clk(clk),
	.i(split_i),
	.left(split_left),
	.right(split_right)
);
fpTreeAdd__WIDTH2 _1(
	.clk(clk),
	.values(_1_values),
	.total(_1_total)
);
fpTreeAdd__WIDTH2 _2(
	.clk(clk),
	.values(_2_values),
	.total(_2_total)
);
fpAdd _3(
	.clk(clk),
	.value1(_3_value1),
	.value2(_3_value2),
	.result(_3_result)
);
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	total = 'x;
	total = __3_result_D24;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	left_part[0] = 'x;
	left_part[1] = 'x;
	for(int _v0 = 0; _v0 < 2; _v0 = _v0 + 1) left_part[_v0] = split_left[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	right_part[0] = 'x;
	right_part[1] = 'x;
	for(int _v0 = 0; _v0 < 2; _v0 = _v0 + 1) right_part[_v0] = split_right[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	split_i[0] = 'x;
	split_i[1] = 'x;
	split_i[2] = 'x;
	split_i[3] = 'x;
	for(int _v0 = 0; _v0 < 4; _v0 = _v0 + 1) split_i[_v0] = values[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	left_total = 'x;
	left_total = _1_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_1_values[0] = 'x;
	_1_values[1] = 'x;
	for(int _v0 = 0; _v0 < 2; _v0 = _v0 + 1) _1_values[_v0] = left_part[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	right_total = 'x;
	right_total = _2_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_2_values[0] = 'x;
	_2_values[1] = 'x;
	for(int _v0 = 0; _v0 < 2; _v0 = _v0 + 1) _2_values[_v0] = right_part[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_3_value1 = 'x;
	_3_value1 = left_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_3_value2 = 'x;
	_3_value2 = right_total;
end
endmodule

// ::fpSplitAt #(
//     T: type ::float,
//     SIZE: 4,
//     SPLIT_POINT: 2,
// )
module fpSplitAt__Ttypefloat_SIZE4_SPLIT_POINT2(
	input clk,
	input wire[31:0] i[3:0],
	output /*mux_wire*/ logic[31:0] left[1:0],
	output /*mux_wire*/ logic[31:0] right[1:0]
);

genvar _g0;
wire[31:0] _2 = i[0];
wire[31:0] _5 = i[1];
wire[31:0] _8 = i[2];
wire[31:0] _11 = i[3];
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	left[0] = 'x;
	left[1] = 'x;
	left[0] = _2;
	left[1] = _5;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	right[0] = 'x;
	right[1] = 'x;
	right[0] = _8;
	right[1] = _11;
end
endmodule

// ::fpTreeAdd #(
//     WIDTH: 2,
// )
module fpTreeAdd__WIDTH2(
	input clk,
	input wire[31:0] values[1:0],
	output /*mux_wire*/ logic[31:0] total
);

genvar _g0;
/*mux_wire*/ logic[31:0] left_part[0:0];
/*mux_wire*/ logic[31:0] right_part[0:0];
/*mux_wire*/ logic[31:0] split_i[1:0];
wire[31:0] split_left[0:0];
wire[31:0] split_right[0:0];
/*mux_wire*/ logic[31:0] left_total;
/*mux_wire*/ logic[31:0] _1_values[0:0];
wire[31:0] _1_total;
/*mux_wire*/ logic[31:0] right_total;
/*mux_wire*/ logic[31:0] _2_values[0:0];
wire[31:0] _2_total;
/*mux_wire*/ logic[31:0] _3_value1;
/*mux_wire*/ logic[31:0] _3_value2;
wire[31:0] _3_result;
/*latency*/ logic [31:0] __3_result_D12; always_ff @(posedge clk) begin __3_result_D12 <= _3_result; end
fpSplitAt__Ttypefloat_SIZE2_SPLIT_POINT1 split(
	.clk(clk),
	.i(split_i),
	.left(split_left),
	.right(split_right)
);
fpTreeAdd__WIDTH1 _1(
	.clk(clk),
	.values(_1_values),
	.total(_1_total)
);
fpTreeAdd__WIDTH1 _2(
	.clk(clk),
	.values(_2_values),
	.total(_2_total)
);
fpAdd _3(
	.clk(clk),
	.value1(_3_value1),
	.value2(_3_value2),
	.result(_3_result)
);
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	total = 'x;
	total = __3_result_D12;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	left_part[0] = 'x;
	for(int _v0 = 0; _v0 < 1; _v0 = _v0 + 1) left_part[_v0] = split_left[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	right_part[0] = 'x;
	for(int _v0 = 0; _v0 < 1; _v0 = _v0 + 1) right_part[_v0] = split_right[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	split_i[0] = 'x;
	split_i[1] = 'x;
	for(int _v0 = 0; _v0 < 2; _v0 = _v0 + 1) split_i[_v0] = values[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	left_total = 'x;
	left_total = _1_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_1_values[0] = 'x;
	for(int _v0 = 0; _v0 < 1; _v0 = _v0 + 1) _1_values[_v0] = left_part[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	right_total = 'x;
	right_total = _2_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_2_values[0] = 'x;
	for(int _v0 = 0; _v0 < 1; _v0 = _v0 + 1) _2_values[_v0] = right_part[_v0];
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_3_value1 = 'x;
	_3_value1 = left_total;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	_3_value2 = 'x;
	_3_value2 = right_total;
end
endmodule

// ::fpAdd #()
module fpAdd(
	input clk,
	input wire[31:0] value1,
	input wire[31:0] value2,
	output /*mux_wire*/ logic[31:0] result
);

/*mux_wire*/ logic[31:0] fpa_s_axis_a_tdata;
/*mux_wire*/ logic[31:0] fpa_s_axis_b_tdata;
wire[31:0] fpa_m_axis_result_tdata;
floating_point_0 #() fpa(
	.aclk(clk),
	.s_axis_a_tdata(fpa_s_axis_a_tdata),
	.s_axis_b_tdata(fpa_s_axis_b_tdata),
	.m_axis_result_tdata(fpa_m_axis_result_tdata)
);
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	result = 'x;
	result = fpa_m_axis_result_tdata;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	fpa_s_axis_a_tdata = 'x;
	fpa_s_axis_a_tdata = value1;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	fpa_s_axis_b_tdata = 'x;
	fpa_s_axis_b_tdata = value2;
end
endmodule

// ::fpSplitAt #(
//     T: type ::float,
//     SIZE: 2,
//     SPLIT_POINT: 1,
// )
module fpSplitAt__Ttypefloat_SIZE2_SPLIT_POINT1(
	input clk,
	input wire[31:0] i[1:0],
	output /*mux_wire*/ logic[31:0] left[0:0],
	output /*mux_wire*/ logic[31:0] right[0:0]
);

genvar _g0;
wire[31:0] _2 = i[0];
wire[31:0] _5 = i[1];
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	left[0] = 'x;
	left[0] = _2;
end
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	right[0] = 'x;
	right[0] = _5;
end
endmodule

// ::fpTreeAdd #(
//     WIDTH: 1,
// )
module fpTreeAdd__WIDTH1(
	input clk,
	input wire[31:0] values[0:0],
	output /*mux_wire*/ logic[31:0] total
);

genvar _g0;
wire[31:0] _2 = values[0];
always_comb begin
	// Combinatorial wires are not defined when not valid. This is just so that the synthesis tool doesn't generate latches
	total = 'x;
	total = _2;
end
endmodule

// ::floating_point_0 #()
// Provided externally
// module floating_point_0(
// 	input aclk,
// 	input wire[31:0] s_axis_a_tdata,
// 	input wire[31:0] s_axis_b_tdata,
// 	output /*mux_wire*/ logic[31:0] m_axis_result_tdata
// );
// 
// 
